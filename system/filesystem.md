##文件系统
### 目标
在完成这篇笔记之后，应该能够回答以下几个问题：
1. 创建一个和已有文件或目录同名的目录将会怎样
2. 删除一个包含子目录的目录将会发生什么事情
3. cd为什么是一个build-in command.
4. 硬链接为什么不能跨越文件系统

###查看当前系统中已挂载的文件系统类型以及占据空间等信息
```bash
    df -T
```
可以看到根文件系统的文件系统类型为ext4, 我们主要分析的文件系统也是基于ext3/4.

###ext2/3/4文件系统
ext2/3/4文件系统将磁道、扇区等抽象成了一个个的块编号。我们可以将一个磁盘划分为一个或多个分区，每个分区上可以存放一个文件系统。每个分区上上的第一个block是boot block, 又被称为主引导记录MBR(Master Boot Record). 第二个及后续的几个block是是super block, 记录该文件系统上的结构信息，例如分区的大小，未被使用的空间大小(bitmap)等等。紧接着，是i-node节点表，每个文件都包含着某些属性，如大小，文件所有者及最近修改时间, 文件在数据块中的位置等等，这些信息通常被保存在一个被称为i-node节点的数据结构中(结构体stat). 分区的最后则是数据区，代表了文件实际的内容。

### 目录、文件及inode
创建一个文件是一件较为简单的事情，首先在super block中的bitmap中找到一个空的inode，然后将这个文件的属性等信息填到对应的stat结构体中，并在相应的数据区中存放文件的实际内容。那么创建一个目录呢？
实际上也是一样的过程，只要明确目录的内容实际上是文件名，包含的是对文件的一个引用, 引用也被称为链接。那么创建一个目录和创建一个文件便没有区别。

### 文件名、inode及链接
要明确的一点是在unix的文件系统中，文件没有文件名，只有inode节点，因此，链接数是针对inode节点的。例如创建一个硬链接，并没有改变文件的inode，但改变了文件名，这里对于该文件来说，链接数+1；尽管这里文件名不同，但实际上都指向了同一个文件。

注意到，软链接和硬链接是不同的。如果对一个文件创建一个软链接，实际上是创建了一个新的文件，因而二者的inode不同，而硬链接没有创建新的文件，因为inode相同。软链接与原始文件的联系在于软链接文件的实际内容为原始文件的名字。

文件名和inode的对应关系保存在一个叫做dirent的结构体中，可以通过man readdir来查看相应的结构。也就是说文件名和inode的一一对应关系保存在目录的实际内容中。

### 总结
OK, 让我们回答一下文章刚开始的几个问题
1. 如果能够创建一个和已有文件或目录相同的目录，这里的相同指的是绝对路径和名称都相同。如果能够创建成功，那么通过文件名能够找到两个相同的inode, 无法确定文件的实际内容，因此，不能创建一个和已有文件或目录相同的目录。
2. 删除一个包含子目录的目录将会发生什么事情
目录中的实际内容是一个又一个的dirent结构体，结构中包含了文件或者目录的name及inode, 那么删除一个包含子目录的目录是一个递归的过程，首先删除目录中的文件所对应的inode结构体以及数据块，然后删除该目录的实际内容和inode结构体等。
3. cd为什么是一个build-in command.
每一个非build-in command的shell命令，都需要在父进程下fork一个子进程，然后由子进程通过exec执行该命令，但由于子进程不会改变父进程的进程环境，因此，程序返回时仍然会处于当前pwd,因此，cd必须是一个build-in command.
4. 硬链接为什么不能跨越一个文件系统
两个文件系统中可能存在着相同的inode, 由于硬链接一个文件，只是将文件名与原始文件的inode绑定，因此，如果两个文件系统中都存在这个inode文件，那么跨越文件系统执行硬链接就可能在一个文件系统中生成两个相同的inode,这显然是不被允许的。
