## job control 
在学完之后，应该回答以下几个问题？
1. 什么是作业控制
2. 为什么使用作业控制
3. 怎样使用作业控制
4. kernel实现作业控制需要什么条件
5. 终端驱动程序和shell之间的区别
6. 如何创建一个会话


### 作业控制的概念
作业控制是BSD在1990年增加的一个概念，它允许在一个终端上开启一个或多个进程作业组，并且其中只有一个前台进程组，前台进程组可以控制该终端，例如从终端上读或者写，后台作业则在后台运行。以上实际上回答了问题1和问题2.

### 怎样使用作业控制
在shell中执行命令时，添加&会使当前进程组成为后台进程组，不添加则会成为前台进程组

### 实现作业控制的条件
kernel实现作业控制，需要以下三个条件
1. 支持作业控制的shell, 即支不支持添加&使当前作业成为后台作业
2. 内核中的终端驱动程序支持作业控制
终端驱动程序可以检测到我们输入的三个特殊字符，将对应的信号发送给前台进程组，使其完成相应的操作。  
1. 中断(Ctrl-C) 产生SIGINT.
2. 退出(Ctrl+\\)产生SIGQUIT.
3. 挂起(Ctrl+Z)产生SIGTSTP
还有一种情况，如果后台作业需要从终端读取字符，终端驱动程序需要检测到这种情况，并向其发送一个SIGTTIN，该信号通常会停止该后台作业，而用户可以通过shell的提示使用fg命令将该作业转为前台作业来执行。

###创建一个会话
我们可以通过setsid命令创建一个session, 命令为setsid [options] program [arguments]. 该session具有以下特点：
1. 该session的会话首进程位program.
2. 该session中目前只有一个进程组，该进程组中的唯一进程为program.该进程组ID和sessionID均为该program进程的pid.
3. 该session没有任何控制终端

#### example
在一个终端/dev/tty3上执行命令setsid ping www.baidu.com, 然后发现屏幕上打印出了Ping命令的输出，但当我们使用Ctrl-C命令终止该终端山上的前台进程组中的所有前台进程时，发现ping命令继续输出。当我们在/dev/tty4上使用ps命令查询到ping命令的pid,ppid,sid等信息时，发现该ping进程没有任何控制终端，其父进程为1(init进程), 这也就意味着ping进程为孤儿进程，因为它不属于/dev/tty3的前台进程组内，所以使用SIGINT中断信号不会对中断该进程，我们应该找到该进程的pid,使用kill命令直接向其发送SIGINT信号。

注意到，这里session没有控制终端，但是可以access一个控制终端，我们可以使用write和read函数向终端读或者写。
