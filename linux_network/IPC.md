## chapter23
### 顺序程序和并发程序特征
顺序程序特征：
1. 顺序性
2. 封闭性(运行环境的封闭性）
程序在运行过程中不会收到其他程序的影响，这里的运行环境主要是指程序状态字、进程上下文、通用寄存器、系统堆栈
3. 确定性
给定输入，无论是运行在性能好的还是性能差的机器上，最后的输出都相同
4. 可再现性
输出结果总是可以再现的
并发程序不具有以上四个特征
对于一个单核的CPU来说，两个进程是交替进行的，不具有顺序性
1. 共享性: 两个并发程序共享运行环境，如通用寄存器、系统堆栈等
2. 并发性: 两个程序交替执行，在同一个时间段内有多个程序在运行
3. 随机性: 运行结果具有随机性


### 进程互斥和进程同步
系统中某些资源一次只允许一个进程使用，这样的资源为临界资源或互斥资源
而进程中涉及到互斥资源的程序段称为临界区

进程同指的是多个进程通过相互配合共同完成一项任务。如售票员和公交司机进程。
我们通常情况下将这两种关系统称为同步关系，需要根据上下文加以理解。

### 进程间通信的目的
1. 数据传输
一个进程将它的数据发送给另一个进程
2. 资源共享
多个进程之间共享同样的资源
3. 通知事件
一个进程需要向另一个进程发送某个消息，如子进程终止时需要给出一个SIGCHLD信号发送给父进程
4. 进程控制
一个进程需要完全控制另一个进程的执行（如DEBUG进程），此时一个进程希望能够完全拦截另外一个进程异常和状态。
可以通过SIGTRAP信号来实现

### 进程间通信的发展
1. 管道
pipe和FIFO
2. System V进程间通信
    2.1 System V消息队列: 用于数据传输
    2.2 System V共享内存: 用于资源共享
    2.3 System V信号量: 用于进程的同步和互斥
3. POSIX进程间通信
    3.1 消息队列
    3.2 共享内存
    3.3 信号量
    3.4 互斥量
    3.5 条件变量
    3.6 读写锁

除此之外，还有文件、文件锁、信号、socket等形式
文件：一个进程写、一个进程读
文件锁：达到互斥和同步目的，一个进程写，不允许另一个进程写或者读，达到互斥目的
信号：如SIGTRAP和SIGCHLD
socket: 网络上的进程之间通信的方式

### 进程之间共享信息的三种方式
1. 两个进程之间通过文件系统来共享信息
    这种方式随文件系统持续，一直存在直到显示删除，如POSIX消息队列，POSIX共享内存和POSIX信号量。
2. 两个进程通过内核中的某些信息来共享
    这种方式IPC对象的持续性随内核持续，一直存在于内核自举（系统重启）或显示删除（如System V消息队列、共享内存和信号量）
3. 两个进程通过用户空间内的某些信息来共享:
    这种方式IPC对象的持续性随进程持续，IPC对象一直存在直到打开的最后一个进程结束(如pipe和FIFO)

## chapter24
### 死锁产生的必要条件
1. 互斥条件：某个资源为互斥资源，同一时刻只能有一个进程占用
2. 占有和保持条件：当进程因请求资源而阻塞时，对已占用的资源保持不放
3. 不可剥夺条件：进程已获得的资源不可剥夺，只可自身主动释放
4. 环路等待条件：各个进程因占用资源而组成封闭的环状链，每个进程都在等待另外一个进程所占用的资源

### 防止死锁的办法
破坏以上四个条件的至少一个
1. 静态分配 (破坏占有和保持条件)
进程在执行之前就必须申请所需的所有资源，且直至所有的资源都满足时，才开始执行
2. 设置可剥夺资源(破坏不可剥夺条件）
资源分配程序在给进程分配资源时，若有则分配，若没有则剥夺该进程所占有的全部资源，并让进程进入资源等待状态，直到资源充足时才唤醒该进程。
3. 资源有序分配法（破坏循环等待条件）
给所有的临界资源编号，一个进程得到某层的一个资源后，只能申请较高一级的资源；释放某层的资源时，必须释放所占的更高一级的资源。

### 死锁避免
那么该采取哪种方法来避免死锁呢？采用的方法应该尽量施加较弱的限制，从而获得较好的系统性能。最有代表的是银行家算法。


### 信号量 P原语和V原语
信号量由迪杰斯特拉提出， 信号量的含义
这里的原语表示原子形式执行
信号量
P和V原语在同一个进程中通常用来解决进程的互斥关系，而P和V在不同进程通常用来解决进程的同步关系.
S>0: S的值表示可用资源的个数
S=0: 表示此时无可用资源，无等待进程
S<0: |S|表示等待队列中进程的个数

P原语
P(S)表示占用当前S资源，如果当前S<=0, 那么就把该进程放置在等待进程中，否则，S值减一，进程占用该S资源
V(S)表示释放当前S资源，如果当前S>=0, 那么就把S的值加一，如果当前S<0, 那么就从等待队列中取出一个进程占用该资源。

## chapter25
### 消息队列
消息队列是用来进程之间数据通信的。
管道和消息队列之间的区别：
1. 管道传输的数据是基于字节流的，数据与数据之间是没有边界的， 而消息队列传输的数据块是有类型的，消息与消息之间是有边界的2. 管道所传输的消息必须就像一个队列，必须要先进先出；而消息队列接收数据时不一定要按照顺序方式来接受。
消息队列的不足，主要有三点：
1. 每个消息的长度是有限的(MSGMAX)     /proc/sys/kernel/msgmax
2. 每个队列中的总的字节数是有限的(MSGMNB))  /proc/sys/kernel/msgmnb
3. 系统中所能存在的消息队列的个数是有限的(MSGMNI) /proc/sys/kernel/msgmni

### IPC数据对象结构
SystemV消息队列是随内核持续的，因此需要内核维护一个数据结构。
内核为每个IPC对象维护了一个数据结构， 即struct ipc\_perm, 可以通过man msgctl来查看这个结构体

### 消息队列结构
struct msqid\)ds，可以通过man msgctl来查看这个结构体。
其第一项即IPC数据对象数据结构


###消息队列在内核中的表示
消息在消息队列中是以链表形式存放的，其本身也是一个结构体，包含四项（下一个消息的地址、消息类型、消息长度和数据本身）

### 消息队列的四个函数
msgget: 创建或者打开一个消息队列
msgctl: 控制消息队列（或者或者改变消息队列的某些性质）
msgsnd: 往消息队列中发送一个消息
msgrcv: 从消息队列中接受一个消息


可以通过ipcs查看共享内存、消息队列、信息量
可以通过ipcrm删除共享内存、消息队列、信息量
由于这些共享内存、消息队列、信息量都是随内核维护(SystemV)或者随操作系统持续(POSIX)，所以必须这些IPC并不会随着进程的消失而消失，必须显示删除。


## chapter28
### 共享内存
共享内存区是内存中的一块特殊的区域，可以用于进程间通信，是最快的IPC形式，一旦共享内存映射到共享它的进程的地址空间，这些进程间数据就不再通过内核，也就是说进程不需要通过执行系统调用来传递彼此的数据。因此，它是最快的IPC形式。
用管道或者消息队列传递数据，对于接收者和传送者都需要分别执行两次内核和进程的拷贝，而用共享内存区传递消息，只需要进行两次拷贝。。
用管道或者消息队列传递数据时，对于echo服务器进程来说，首先需要从套接字中读取数据，然后往套接字中写入数据；对于echo客户端进程来说，首先需要向套接字中(管道或者消息队列）中写入消息，然后再从套接字中读入消息，总计4次系统调用, 相当于四次从内核拷贝数据到进程空间或者从进程空间拷贝数据到内核。

而对于共享内存来说，我们可以将共享内存区映射到服务器进程和客户端进程中；而我们只需要两次拷贝即可，使用read函数从内核拷贝数据到共享内存区，使用write函数从共享内存区拷贝数据到内核。

我们可以使用mmap函数将文件或者设备映射到共享内存区。

### mmap注意点
1. 映射不能改变文件的大小
2. 可用于进程间通信的有效地址空间不完全受限于被映射文件的大小
3. 文件一旦被映射，所有对mmap返回指针的访问，实际上是对文件的访问，映射区域写回文件时，所写内容不能超过文件的大小。

## chapter29
shmget: 创建一个共享内存区, 只标识了该共享内存区的id和key，而没有生成共享内存区的大小和地址。
shmat: 确定共享内存区的地址和长度，然后attach该共享内存区和进程空间。
shmdt: detach共享内存区和进程空间。
shmctl: control 共享内存区的属性

## chapter30
### 信号量集函数
1. semget： 创建一个信号集
semget(key\_t key, int nsems, int semflg);
key: 信号集的名字
nsems: 信号集中信号量的个数
semflg: 权限标志
2. semctl: control信号量集的性质
semctl(int semid, int semnum, int cmd, ...);
semid: semget返回的信号集标识码
semnum: 信号集中信号量的序号(从0开始）
cmd: 将采取的动作(有三个可取值）
3. semop: 对该信号量集进行操作

## chapter34
可以使用man 7 mq\_overview来查看posix message queue的一个大致overview.
同样，man 7 shm\_overview来查看posix shared memory的一个大致overview.
