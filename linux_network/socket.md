## 什么是socket

socket可以看作是用户进行与内核网络协议栈的编程接口。tcp/ip协议栈中的传输层网络层、链路层已经封装在了内核中，我们只需要调用socket函数即可在应用层直接在对等层之间进行通信。

优点是，socket可以在异构系统中进行通信，可以在不同的硬件平台上进行通信(ARM vs x64)， 也可以在不同的操作系统上进行通信(linux, mac, windows).

### IPv4套接字结构
主要包含三个部分：端口，地址和地址家族，地址家族指明了通信的协议，如TCP/IP协议，UNIX域协议、UDP/IP协议等。

### 通用域结构
为什么要有通用的域结构，原因在于，sockaddr\_in结构只能用于IPv4套接字结构，sockaddr\_un只能用于unix域套接字结构，而sockaddr能用于任何结构的套接字接口，我们在编程时应该应将sockaddr\_in结构强制转换成sockaddr结构。

### 网络字节序
不同的主机有不同的字节序，一般x86/64平台上均为小端字节序，最高有效位存储在最高内存地址处。ARM平台次序是可配置的.

网络字节序固定为大端字节序,

### 地址转换函数

计算机无法识别如"127.0.0.1"这样的点分10进制字段，能够识别的是由32位的整数地址，因此，需要有一个地址转换函数将点分10进制字段转换为32位整数地址，inet\_addr.

inet\_ntoa函数将32位整数地址转化为点分10进制的IP地址。


### listen函数
listen函数的第二个参数规定了内核为此套接字排队的最大连接个数。
对于给定的监听套接字，内核要维护两个队列：
1. 等待三个握手完成的套接字
2. 已完成连接的套接字
当客户的SYN到达时，内核要在未完成连接的队列中创建一个新项，然后返回ACK，当客户的ACK到达时，该新项加入已连接套接字的队尾; connect函数从已连接套接字的队列中取出头套接字进行服务器和客户端的连接，相当于减少一个已完成连接的套接字。

listen的第二个参数backlog规定了内核为此套接字排队的最大连接个数。其值是一个system implement, 有的系统设置listenlog为两个队列的总和，有的系统设置listenlog为未连接队列的1.5倍。一般认为，二者之和不超过backlog.

### accept函数
从已连接队列中返回队头进行连接，若已连接队列为空，那么阻塞当前进程，直至已连接队列中存在监听套接字。


### bind error
这种错误大多数出现在服务器端主动关闭且处于TIME\+TIME状态，因而IP地址和端口并占用，无法重复绑定。

在这种情况下可以使用setsockopt函数，设置SO\_REUSEADDR选项，从而使得即使是在TIME\_WAIT状态下也能继续bind.

使用方法为:
```c
    int on = 1;
    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
```



## 粘包及解决方案
粘包指的是接收端一次recv接收到了多次send的数据包或者一次recv没有接受完一次send的数据，从而无法解析的过程.实际上不存在粘包这个概念，是应用层自己没有处理好数据格式。
### 粘包出现的原因
1. 套接口缓冲区较小
因而，一个应用产生的消息可能大于套接口缓冲区大小，因而，该数据包必须要分割开才能发送，一部分可能已经发送，另外一部分才被送到套接字缓冲区，因此会出现粘包。
2. TCP的MSS 
这里面可能会对应用产生的消息进行分割
3. IP中的MTU
同样，可能会对TCP报文段进行分组，产生粘包

### 粘包问题的解决方案
1. 发送定长包
2. 包尾加上\r\n(ftp)
3. 包头加上包体长度
4. 更复杂的应用层协议
方案2可能必须要进行转义。
对于方案1，由于read或者write一个套接字可能比请求的字节数量要少。这是因为内核的缓冲区可能较小，一次read或write要求的字节数量大于其缓冲区大小，因此，调用者需要再次调用一个read或write函数，完成后面的字节请求。
我们这里要求发送接受定长包，因此，这里不允许处理的字节数量小于请求数量。因此，我们需要封装read函数和write函数，以满足要求。


### static函数与可重入不可重入问题
### readn, writen, readline
为什么用readn, writen替代read, write
其实仔细分析，无论是阻塞方式还是非阻塞方式读取socket, readn和writen及read,write都差别不大
若read, 或者write以阻塞方式读取一个socket时，那么readn和writen与read及write没有区别；
对于read而言，若内核缓冲区内没有字符可以读取，那么就阻塞，直到内核缓冲区内有字符，或者peer端关闭了socket连接；对于write而言，若内核缓冲区是满的，那么就阻塞，知道内核缓冲区内有字符，或者peer端关闭了socket连接。
而用read或者write已非阻塞方式读取socket时，那么readn和writen与read及write也应该是相同的：
差别在于对于EINTR错误的处理，read和write函数阻塞情况下一旦捕捉到某个信号，且相应的信号处理函数返回时，read或者write函数会返回一个EINTR错误，默认处理是终端该程序，在readn和writen中，我们不认为这是错误，因此，忽略继续执行read或者write.

另外一个不同点是在对等端关闭时，read或者write函数返回0，而在readn或者writen函数中，我们返回的已读取或者已写的元素个数。

### waitpid与僵尸进程
客户端关闭时，发送一个FIN信号给服务器，表明对端关闭，此时子进程的read返回0，子进程终止。子进程终止，操作系统发送一个SIGCHLD信号给父进程，此时父进程若未明确对SIGCHLD信号给与处理，那么这时候就会出现僵死进程。

我们应该使用signal函数处理SIGCHLD信号，在signal信号中使用waitpid函数，退出子进程

## TCP的11种状态
closing状态是指处于FIN\_WAIT\_1状态时收到了一个FIN，若在closing状态接收到了一个ACK, 那么就处于TIME\WAIT状态， 若FIN\_WAIT\_1状态时收到了ACK和FIN，那么就处于FIN\_WAIT\_2状态。FIN\_WAIT\_2状态收到了一个FIN就处在TIME\_WAIT状态。

### FIN\_WAIT\_2和CLOSE\_WAIT
在第12节课中，对应echosrv5.c和echocli.c，若服务器端首先调用close函数关闭连接套接字(相当于kill子进程), 那么服务端将处于FIN\_WAIT\_2状态，而客户端处于CLOSE\_WAIT状态，因为客户端是属于被动关闭，那么它将一直阻塞于fgets(从键盘上输入)，而没有机会调用read函数，read函数也就不会返回0，也就没有机会调用close函数，因而无法给客户端发送FIN报文段，因此，服务器端将处于FIN\_WAIT\2状态，服务器端处于CLOSE\_WAIT状态。而一旦在客户端输入数据，fgets函数返回，客户端将有机会调用read函数和close函数，因此，将发送一个FIN报文段给服务器端，客户端将处于CLOSED状态。但是这时服务器端连接子进程已经消失，将不会处于TIME\_WAIT状态。

###SIGPIPE
当服务器端主动关闭时，我们可以看到，客户端还可以向服务器端发送数据，这是因为，TCP是双全工的，服务器端关闭只意味着不会传送数据，而并不意味着不会接收数据。因此，我们还可以通过write函数向服务器端发送数据。如果使用write函数发送数据时，服务器端连接子进程已经不存在，将会导致TCP的RESET. 服务器端将会发送一个RST报文段，若收到RST报文段后再次write就会产生一个SIGPIPE信号。

### TIME\_WAIT和CLOSED状态
若在客户端调用close函数关闭连接套接字, 那么客户端将处于TIME\_WAIT状态，服务器端将处于CLOSED状态。


