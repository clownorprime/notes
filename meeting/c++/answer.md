### 指针和引用的概念
指针和引用都能够实现间接的访问某个对象
指针是一个对象，其本身存储的是所指对象的虚拟内存地址，而引用是一个变量的别名.

### 指针和内存的关系
指针所处的地址上存放的值是其指向元素的地址。

### 底层const和顶层const
底层const指的是指针所指的对象是一个const,我们无法修改指针所指向对象的值，但是我们可以修改指针本身的值，即我们可以使指针指向其他对象。
顶层const指的是指针本身是一个const,我们无法修改指针，使其指向其他对象，但是我们可以修改指针所指向的对象的值

观察一个指针+const的组合是顶层const还是底层const, 可以从右向左观察，比如：
const int\*p = &a; 这是一个底层const, const针对int
int \* const p = &a; 这是一个顶层const, const限制的是int\*

### 程序编译过程
gcc -E source.c 预处理阶段，替换宏定义等
gcc -S source.c -o source.asm 编译阶段，将源代码编译成为汇编代码
gcc -c source.asm -o source.o 汇编阶段，将汇编代码翻译为目标文件
ld source.o \*.o 链接阶段，将一大堆的目标文件链接成为可执行文件。

### c和c++区别
c和c++都是编译性、静态类型语言
编译性与解释性相对应，解释性语言通过解释器来翻译成为机器语言来进行执行。例如对于shell、python等解释性语言，如果我们想要某个程序执行多次，那么每一次都需要解释器将其翻译成为对应的机器语言。而对于编译性语言，我们只需要使用编译器一次执行相应的可执行文件，从而执行多次。
编译型语言的优点，不需要提供相应的环境，可以直接运行，如java等解释性语言必须安装jvm虚拟机等。

c++有多种编程范式
既可以象c语言一样面向过程，也就是面向函数编程
也可以像java一样，面向对象编程
为了实现代码的复用，也可以使用泛型编程
还可以采用元编程的编程范式

### 内存模型
c++的内存模型
包括代码段、数据段
为什么要分为代码段和数据段
1. 在链接时，我们需要将多个目标文件的代码段链接在一起成为可执行文件的代码段，我们可以设置代码段为只读，从而防止进程修改程序的指令。
2. 将代码段和数据段分开有助于提高缓存的命中率，现代CPU的缓存一般都被设计成为数据缓存和指令缓存分离
3. 将代码段和数据段分开，那么假设有多个可执行文件都需要printf.o的目标文件，那么这个时候，我们就可以在内存中仅保存一份printf.o的副本，采用动态链接的方法，将printf.o所在的位置填写在可执行文件中，那么可以节省大量的内存。
### 内存中的堆和栈分配
注意到
vector的元数据（记录vector的信息，如size, addr)等保存在栈区，而vector的实际数据保存在堆区。

### 面向对象理解
面向对象的核心思想是数据抽象，继承和动态绑定
数据抽象,也就是封装, 将类的实现和接口分离，通过封装，可以控制对数据的访问，提高代码的可维护性和安全性
继承:允许从现有的类中派生出其他的类，新的类继承了父类的属性和行为，并可以在其基础上进行修改，继承有助于提高代码的可重用性。
多态：多态指的是对象的多种表现形态。通过多态，可以在不同的对象上调用相同的方法，实际执行的操作会依据对象的具体类型而又所不同。多态提高了代码的可维护性和拓展性。
抽象：将对象的共同特征抽象出来，成为类或者接口的过程。

### 析构函数

### 什么是抽象类
抽象类指的是一个类中包含了至少一个纯虚函数，纯虚函数指的是只提供了函数的声明，而没有函数具体的实现的虚函数。
抽象类无法实例化，无法产生具体的对象，其子类必须要实现该虚函数。

### struct和class的区别
struct和class有以下几点区别：
1. 默认的成员访问控制不同
struct中，所有的成员默认为是public, 而class中，所有的成员默认是private
2. struct不支持多态和继承，而class支持多态和继承

### struct内存对齐
对齐主要是由于CPU是按照地址读取的，如果内存是非对齐的，那么CPU读取一个int值，可能必须要访问两次内存，如果地址是对齐的，那么只需要访问一次内存.

### sizeof和strlen的区别
首先，sizeof是一个运算符(就像+, -等)，而strlen是一个函数
其次，sizeof计算的是变量所占空间的大小，而strlen计算的是字符串的长度。
如:
```c
char array[1000];
memset(array, '\0', 1000);
printf("strlen(array) = %d\n", strlen(array));
printf("sizeof(array) = %d\n", sizeof(array));
```
strlen返回的是0, 而sizeof返回的是1000.

### struct和union的共同点和区别
struct和union中都可以持有不同类型的数据.
不同的是struct中所有元素是共存的，而union中元素是互斥的。union的最主要功能是节省内存空间。
union中的所有元素共享同一个内存首地址，union的大小等于union中元素所占内存空间的最大值.

### new/delete和malloc/free的区别
1. new能够自动计算需要分配的内存空间，而malloc需要手动计算需要分配的内存空间
2. new其实包含两个过程，一是使用malloc函数分配空间，而是调用构造函数构造对象；同样，delete也包括两个过程，调用析构函数和释放内存空间.
3. new返回带具体类型的指针，而malloc返回空类型的指针.
### 野指针
野指针（wild pointer），也就是悬挂指针(hang pointer), 指的是无法正常使用的指针。
比如
1. 未初始化的指针
2. 使用delete或者free后的指针(在delete后，应设该指针为NULL）
这些指针所指向的元素是一个随机值，所以无法正常使用，

### static关键字
在c语言中，static主要有两个特点：
1. 无论static修饰的是一个全局变量还是局部变量，static的存续期都会持续到整个程序接受，这是因为static修饰的变量被放置在了全局变量区。另外，static修饰的全局变量和局部变量二者之间没有明显的区别。因此，在一个函数中，我们初始化了一个static局部变量，并且在该函数中，将这个变量值+1，那么下一次调用该函数时，static局部变量的值为初始值+1，再调用一次，值为初始值+2
2. static修饰的变量仅仅在声明它的文件中可见，其他文件不可见，所以无法使用extern关键字引用另外一个文件中的static变量
由于c++是c语言的超集，因此，static在c语言中的特征在c++中也适用，但是static关键字在c++有另外的用途.
1. static修饰类中成员变量
static修饰的类成员变量被称为静态数据成员，静态数据成员必须要在类中声明，在类外定义；另外，静态数据成员属于类本身，不属于任何对象。因为，静态数据成员在所有的对象中是共享的，而非静态数据成员，每一个对象都有一份拷贝.但是静态数据成员对该类的所有对象均可见.
因此，静态数据成员更像是一个全局变量，但是相比于全局变量，它有其独特的优势：
1）静态数据成员没有进入到程序的全局名字空间，因而不存在与程序中其他全局名字冲突的可能性
2) 可以实现信息隐藏，静态数据成员可以是private, 而全局变量不可以
2. static修饰类中成员函数
静态成员函数有以下特点：
1. this指针指向当前对象的地址，而static成员不属于任何一个对象，因此，它没有this指针，因此，它无法访问类中的非静态成员. 也无法调用非静态成员函数，只能够调用静态成员函数.
但是普通成员函数可以访问静态成员，对象也可以访问静态成员，需要遵循public, private, protected等规则.
2. 静态函数可以在类内定义，也可以在类外定义.

### this指针
this指针本身是一个常量指针，其指向的是一个对象，并且必须是这个对象，不能指向其他的对象。它所指对象的内容是可以修改的.
考虑一个类A, 其有一个非const成员函数func(), 那么，其本质上这个func函数的形参是func(A\* const this), 即该指针是一个顶层const指针。
那么对于一个const对象a, 如果让它调用一个非const成员函数，那么这时候this应该是一个const A\* const, 即指针本身指向的内容也不可以更改。由于const是无法隐式转换为非const的，所以这里const对象是无法调用非const成员函数。而const对象调用const成员函数，this指针的类型完全合适，所以const对象可以调用const成员函数。

另外，对于非const对象，由于非const向const的转换是隐式进行的，所以这里相当于从A\* const 自动转换为const A\* const, 因此，非const对象也可以调用const成员函数。并且，如果const成员函数与非const成员函数形参完全相同时（仅仅this指针的类型不同），非const对象首先调用非const成员函数，不需要发生隐式类型转换.

### const关键字
#### const修饰成员函数
const成员对象只能调用const成员函数，不能调用非const成员函数；非const成对象既可以调用非const成员函数，也可以调用const成员函数.

对于const成员数据和非const成员数据，const对象和非const对象都可以使用.

### extern关键字
在c语言中，使用extern关键字是告知编译器，其声明的函数或者变量能够在本模块或者其他模块中使用。

### 面向对象的三大特征
封装, 将类的实现和接口分离，通过封装，可以控制对数据的访问，提高代码的可维护性和安全性
继承:允许从现有的类中派生出其他的类，新的类继承了父类的属性和行为，并可以在其基础上进行修改，继承有助于提高代码的可重用性。
多态：多态指的是对象的多种表现形态。通过多态，可以在不同的对象上调用相同的方法，实际执行的操作会依据对象的具体类型而又所不同。多态提高了代码的可维护性和拓展性。


### 类的访问权限与继承
类的访问权限，对于类的对象而言，只能访问类的公有成员，受保护的成员和私有成员不可见。
继承分为公有继承、保护继承和私有继承
无论是公有继承、保护继承还是私有继承，对于派生类而言，基类的公有成员和保护成员均可访问，而私有成员都是不可访问的。而对于派生类的对象而言，规定则较为复杂。
对于公有继承，派生类的对象可以访问基类的公有成员，无法访问基类的保护成员和私有成员；对于私有继承，基类的所有成员均无法访问；对于保护继承，只是将基类中的public访问变为protected, 这意味着，派生类的对象均无法访问基类的成员.

### 移动拷贝函数和拷贝构造函数对比
#### 拷贝构造函数调用时机
拷贝构造函数调用的三个时机：
1. 函数的形参是一个类的对象
当将一个类的对象传入函数时，会形成一个临时对象，然后这时编译器就调用一个拷贝构造函数将类的对象拷贝到临时对象上，等函数执行完毕后，再调用析构函数析构掉该临时变量。为了避免这种情况，我们传递参数时要传递一个引用，从而避免了拷贝构造过程。
2. 函数的返回值是一个类的对象
比如我们在函数中首先创建了一个类的对象，然后调用return函数将其返回，那么在返回时，首先创建了一个临时对象，然后调用拷贝构造函数拷贝到临时对象上，等函数执行到最后，首先析构掉该临时对象，在析构掉创建的对象.
3. 对象需要另外一个对象进行初始化。
如 Example A(100);
   Example B = A;
在这个过程中，B对象是调用了拷贝构造函数将对象A的值拷贝赋值给了B. 这和下面的例子不同：
Example A(100);
Example B;
B = A;
在这个过程中，首先B使用了缺省的默认构造函数，然后调用了一个赋值构造函数将A的值赋值给了B.
note:要想在程序中验证这一结论，要关闭g++的RVO(return value optimation)优化，即g++ -fno-elide-constructors.

#### 浅拷贝和深拷贝
1. 默认的拷贝构造函数
如果我们不指定拷贝构造函数，那么编译器将会为我们自动生成一个默认的拷贝构造函数
2. 浅拷贝
但是默认的拷贝构造函数进行的只是浅拷贝，即在对象复制时，只是对对象中的数据成员进行简单的赋值。但是一旦对象中存在动态成员，那么浅拷贝就会失效。

假设对象中有个指针，需要动态分配内存，那么这时候，浅拷贝在对对象进行拷贝的过程中，会让两个对象中的指针指向同一块物理内存，那么当进行对象析构时，析构了第一个对象，那么了另外一个对象的指针就会变成一个野指针，因而析构时也会出错。
